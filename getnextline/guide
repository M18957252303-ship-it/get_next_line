1. goal: write a function to read from different file descriptors line(end with \n) by line.

2. external functions: read, malloc, free
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
It reads up to count bytes from the file descriptor fd into the buffer starting at buf(without moving the pointer buf). It reads data from the current file offset and increments the file offset by the number of bytes read, which means it can recall it from its current position within the file until the file offset is at or past the end of the file, no bytes are read, and returns zero. 
*Whatever it recalls, it will write into the buffer from the same position, which means it will cover what it wrote last time. So if we want to continue accumulating from where it left off last time, we need to manage the pointer buf manually.

3. to achieve "read by line", we need a buffer.
-- A buffer is a region of memory used to temporarily store data while it is being transferred from one place to another.

4. use a loop to read by multiple times; and use static variable to keep its valve after each read.
This process continues until all the data has been read from the file or an error occurs. The buffer is null-terminated after each read to ensure it can be printed as a string. 

5. use strxx functions to manage the line.

6. boundary conditions:
-- only \n in one line
-- no \n at the end of the file
-- empty file

7. key concepts:
-- Static variables
are stored in the static memory area and are initialized only once during the program's lifetime. If not explicitly initialized, they are automatically set to 0 for numeric types or NULL for pointers.

Global variables:
Visible everywhere (unless declared static for internal linkage)
Stored in static storage
Exist for the entire program

Static local variables: declared inside a function
- to make local variable remember its value
Visible only in the block where declared
Stored in static storage (NOT on the stack)
They live for the entire program, even though their scope is only within the function.
* Value persists across function calls (only be created once and remember its value from last call)

Static global variables: declared outside a function
- to make global variable private to the file


Local variables:
Visible only in the block where declared
Stored on the stack
Lifetime limited to the execution of the block

-- Block scope 
refers to the visibility and lifetime of variables, constants, or arrays declared within a specific block of code. A block is defined by a pair of curly braces {}. Variables declared inside a block are only accessible within that block and are destroyed when the block is exited, freeing up memory. All the local variables belong to block-scope variables, due to a function itself is a block.
* Block-scope variables are not automatically initialized. Using uninitialized variables can lead to undefined behavior.
* Accessing a block-scope variable outside its block results in a compilation error.
-- 
8. sources:
-- https://dev.to/aerrfig/get-next-line-a-42-project-to-learn-how-to-deal-with-file-descriptors-and-io-of-system-3652
-- https://blog.51cto.com/u_15288375/14088123?
-- https://www.codequoi.com/en/local-global-static-variables-in-c/#a-local-variables-scope
